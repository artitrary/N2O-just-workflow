#!/bin/bash
set -e

# =============================================================================
# n2o — N2O Workflow Framework CLI
# Usage:
#   n2o init <project-path> [--interactive] [--register]
#   n2o sync <project-path> [--dry-run]
#   n2o sync --all [--dry-run]
# =============================================================================

N2O_DIR="$(cd "$(dirname "$0")" && pwd)"
MANIFEST="$N2O_DIR/n2o-manifest.json"
PROJECTS_FILE="$N2O_DIR/.n2o-projects.json"
VERSION=$(jq -r '.version' "$MANIFEST")

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

log_info()    { echo -e "${BLUE}ℹ${NC}  $1"; }
log_success() { echo -e "${GREEN}✓${NC}  $1"; }
log_warn()    { echo -e "${YELLOW}⚠${NC}  $1"; }
log_error()   { echo -e "${RED}✗${NC}  $1" >&2; }
log_header()  { echo -e "\n${BOLD}$1${NC}"; }

check_deps() {
  for cmd in jq sqlite3; do
    if ! command -v "$cmd" &>/dev/null; then
      log_error "Required dependency '$cmd' not found. Please install it."
      exit 1
    fi
  done
}

# Check if a path matches any pattern in a JSON array field from the manifest.
# Uses simple glob matching (** means recursive).
is_project_file() {
  local rel_path="$1"
  local patterns
  patterns=$(jq -r '.project_files[]' "$MANIFEST")
  while IFS= read -r pattern; do
    # Convert glob pattern to a simple check
    # Remove trailing **
    local prefix="${pattern%%/\*\*}"
    if [[ "$prefix" != "$pattern" ]]; then
      # Pattern ends with /**, match anything under that prefix
      if [[ "$rel_path" == "$prefix"/* || "$rel_path" == "$prefix" ]]; then
        return 0
      fi
    else
      # Exact match
      if [[ "$rel_path" == "$pattern" ]]; then
        return 0
      fi
    fi
  done <<< "$patterns"
  return 1
}

# Get the list of framework source directories/files from the manifest
get_framework_sources() {
  jq -r '.framework_files[]' "$MANIFEST"
}

# Replace template placeholders in a file
fill_template() {
  local file="$1"
  local project_name="$2"
  local test_cmd="$3"
  local typecheck_cmd="$4"
  local lint_cmd="$5"
  local build_cmd="$6"

  sed -i \
    -e "s|{{project_name}}|${project_name}|g" \
    -e "s|{{test_command}}|${test_cmd}|g" \
    -e "s|{{typecheck_command}}|${typecheck_cmd}|g" \
    -e "s|{{lint_command}}|${lint_cmd}|g" \
    -e "s|{{build_command}}|${build_cmd}|g" \
    "$file"
}

# Register a project path in .n2o-projects.json
register_project() {
  local project_path="$1"
  
  if [[ ! -f "$PROJECTS_FILE" ]]; then
    echo '{"projects":[]}' > "$PROJECTS_FILE"
  fi

  # Check if already registered
  if jq -e --arg p "$project_path" '.projects | index($p)' "$PROJECTS_FILE" &>/dev/null; then
    log_info "Project already registered: $project_path"
    return 0
  fi

  # Add to registry
  local tmp
  tmp=$(mktemp)
  jq --arg p "$project_path" '.projects += [$p]' "$PROJECTS_FILE" > "$tmp"
  mv "$tmp" "$PROJECTS_FILE"
  log_success "Registered project: $project_path"
}

# Detect project type from package.json etc.
detect_project() {
  local project_path="$1"
  
  PROJECT_TYPE="unknown"
  PKG_MANAGER=""
  DEFAULT_TEST=""
  DEFAULT_TYPECHECK=""
  DEFAULT_LINT=""
  DEFAULT_BUILD=""

  if [[ -f "$project_path/package.json" ]]; then
    PROJECT_TYPE="node"
    
    # Detect package manager
    if [[ -f "$project_path/pnpm-lock.yaml" ]]; then
      PKG_MANAGER="pnpm"
    elif [[ -f "$project_path/yarn.lock" ]]; then
      PKG_MANAGER="yarn"
    elif [[ -f "$project_path/bun.lockb" ]]; then
      PKG_MANAGER="bun"
    else
      PKG_MANAGER="npm"
    fi

    # Read scripts from package.json to set defaults
    local scripts
    scripts=$(jq -r '.scripts // {}' "$project_path/package.json" 2>/dev/null || echo '{}')
    
    if echo "$scripts" | jq -e '.test' &>/dev/null; then
      DEFAULT_TEST="$PKG_MANAGER test"
    fi
    if echo "$scripts" | jq -e '.typecheck' &>/dev/null; then
      DEFAULT_TYPECHECK="$PKG_MANAGER typecheck"
    elif echo "$scripts" | jq -e '."typecheck:all"' &>/dev/null; then
      DEFAULT_TYPECHECK="$PKG_MANAGER typecheck:all"
    fi
    if echo "$scripts" | jq -e '.lint' &>/dev/null; then
      DEFAULT_LINT="$PKG_MANAGER lint"
    elif echo "$scripts" | jq -e '."lint:all"' &>/dev/null; then
      DEFAULT_LINT="$PKG_MANAGER lint:all"
    fi
    if echo "$scripts" | jq -e '.build' &>/dev/null; then
      DEFAULT_BUILD="$PKG_MANAGER build"
    fi
  elif [[ -f "$project_path/Cargo.toml" ]]; then
    PROJECT_TYPE="rust"
    PKG_MANAGER="cargo"
    DEFAULT_TEST="cargo test"
    DEFAULT_BUILD="cargo build"
    DEFAULT_LINT="cargo clippy"
  elif [[ -f "$project_path/pyproject.toml" ]] || [[ -f "$project_path/setup.py" ]]; then
    PROJECT_TYPE="python"
    DEFAULT_TEST="pytest"
    DEFAULT_LINT="ruff check"
  elif [[ -f "$project_path/go.mod" ]]; then
    PROJECT_TYPE="go"
    DEFAULT_TEST="go test ./..."
    DEFAULT_BUILD="go build ./..."
    DEFAULT_LINT="golangci-lint run"
  fi
}

# Prompt user for a value with a default
prompt_value() {
  local prompt="$1"
  local default="$2"
  local result

  if [[ -n "$default" ]]; then
    read -rp "  $prompt [$default]: " result
    echo "${result:-$default}"
  else
    read -rp "  $prompt: " result
    echo "$result"
  fi
}

# =============================================================================
# INIT COMMAND
# =============================================================================

cmd_init() {
  local project_path=""
  local interactive=false
  local do_register=false

  # Parse args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --interactive) interactive=true; shift ;;
      --register)    do_register=true; shift ;;
      -*)            log_error "Unknown option: $1"; exit 1 ;;
      *)             project_path="$1"; shift ;;
    esac
  done

  if [[ -z "$project_path" ]]; then
    log_error "Usage: n2o init <project-path> [--interactive] [--register]"
    exit 1
  fi

  # Resolve to absolute path
  project_path="$(cd "$project_path" 2>/dev/null && pwd || mkdir -p "$project_path" && cd "$project_path" && pwd)"

  log_header "Initializing N2O workflow in: $project_path"

  # Check if already initialized
  if [[ -f "$project_path/.pm/config.json" ]]; then
    local existing_version
    existing_version=$(jq -r '.n2o_version // "unknown"' "$project_path/.pm/config.json")
    log_warn "Project already initialized (v$existing_version). Use 'n2o sync' to update framework files."
    read -rp "  Continue anyway? (y/N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
      exit 0
    fi
  fi

  # ---- Step 1: Create directory structure ----
  log_header "1. Creating directory structure"
  local dirs
  dirs=$(jq -r '.directory_structure[]' "$MANIFEST")
  while IFS= read -r dir; do
    if [[ ! -d "$project_path/$dir" ]]; then
      mkdir -p "$project_path/$dir"
      log_success "Created $dir/"
    else
      log_info "Exists: $dir/"
    fi
  done <<< "$dirs"

  # ---- Step 2: Copy framework files ----
  log_header "2. Copying framework files"

  # Skills → .claude/skills/
  if [[ -d "$N2O_DIR/02-agents" ]]; then
    cp -r "$N2O_DIR/02-agents/"* "$project_path/.claude/skills/" 2>/dev/null || true
    log_success "Copied agents → .claude/skills/"
  fi

  if [[ -d "$N2O_DIR/03-patterns" ]]; then
    # Copy pattern directories into skills
    cp -r "$N2O_DIR/03-patterns/"* "$project_path/.claude/skills/" 2>/dev/null || true
    log_success "Copied patterns → .claude/skills/"
  fi

  # Schema → .pm/schema.sql
  if [[ -f "$N2O_DIR/.pm/schema.sql" ]]; then
    cp "$N2O_DIR/.pm/schema.sql" "$project_path/.pm/schema.sql"
    log_success "Copied schema.sql → .pm/"
  fi

  # Scripts → scripts/
  if [[ -d "$N2O_DIR/scripts" ]]; then
    cp -r "$N2O_DIR/scripts/"* "$project_path/scripts/" 2>/dev/null || true
    # Make scripts executable
    find "$project_path/scripts" -name "*.sh" -exec chmod +x {} \;
    log_success "Copied scripts → scripts/"
  fi

  # ---- Step 3: Detect project & gather config ----
  log_header "3. Configuring project"
  detect_project "$project_path"

  local project_name
  project_name="$(basename "$project_path")"
  local test_cmd="$DEFAULT_TEST"
  local typecheck_cmd="$DEFAULT_TYPECHECK"
  local lint_cmd="$DEFAULT_LINT"
  local build_cmd="$DEFAULT_BUILD"

  if [[ "$PROJECT_TYPE" != "unknown" ]]; then
    log_info "Detected: $PROJECT_TYPE project (package manager: ${PKG_MANAGER:-none})"
  fi

  if $interactive; then
    log_info "Interactive mode — press Enter to accept defaults"
    project_name=$(prompt_value "Project name" "$project_name")
    test_cmd=$(prompt_value "Test command" "$test_cmd")
    typecheck_cmd=$(prompt_value "Typecheck command" "$typecheck_cmd")
    lint_cmd=$(prompt_value "Lint command" "$lint_cmd")
    build_cmd=$(prompt_value "Build command" "$build_cmd")
  fi

  # ---- Step 4: Scaffold project files from templates ----
  log_header "4. Scaffolding project files"

  # config.json
  if [[ ! -f "$project_path/.pm/config.json" ]]; then
    cp "$N2O_DIR/templates/config.json" "$project_path/.pm/config.json"
    # Fill in detected/provided values
    local tmp
    tmp=$(mktemp)
    jq \
      --arg ver "$VERSION" \
      --arg name "$project_name" \
      --arg test "$test_cmd" \
      --arg tc "$typecheck_cmd" \
      --arg lint "$lint_cmd" \
      --arg build "$build_cmd" \
      '.n2o_version = $ver | .project_name = $name | .commands.test = $test | .commands.typecheck = $tc | .commands.lint = $lint | .commands.build = $build' \
      "$project_path/.pm/config.json" > "$tmp"
    mv "$tmp" "$project_path/.pm/config.json"
    log_success "Created .pm/config.json"
  else
    log_info "Exists: .pm/config.json (skipped)"
  fi

  # CLAUDE.md
  if [[ ! -f "$project_path/CLAUDE.md" ]]; then
    cp "$N2O_DIR/templates/CLAUDE.md" "$project_path/CLAUDE.md"
    fill_template "$project_path/CLAUDE.md" "$project_name" "$test_cmd" "$typecheck_cmd" "$lint_cmd" "$build_cmd"
    log_success "Created CLAUDE.md"
  else
    log_info "Exists: CLAUDE.md (skipped)"
  fi

  # schema-extensions.sql
  if [[ ! -f "$project_path/.pm/schema-extensions.sql" ]]; then
    cp "$N2O_DIR/templates/schema-extensions.sql" "$project_path/.pm/schema-extensions.sql"
    log_success "Created .pm/schema-extensions.sql"
  else
    log_info "Exists: .pm/schema-extensions.sql (skipped)"
  fi

  # ---- Step 5: Initialize database ----
  log_header "5. Initializing task database"
  if [[ ! -f "$project_path/.pm/tasks.db" ]]; then
    sqlite3 "$project_path/.pm/tasks.db" < "$project_path/.pm/schema.sql"
    if [[ -f "$project_path/.pm/schema-extensions.sql" ]] && [[ -s "$project_path/.pm/schema-extensions.sql" ]]; then
      # Only run if file has actual SQL (not just comments)
      if grep -qE '^\s*(CREATE|ALTER|INSERT|DROP)' "$project_path/.pm/schema-extensions.sql" 2>/dev/null; then
        sqlite3 "$project_path/.pm/tasks.db" < "$project_path/.pm/schema-extensions.sql"
        log_success "Applied schema extensions"
      fi
    fi
    log_success "Created .pm/tasks.db"
  else
    log_info "Exists: .pm/tasks.db (skipped)"
  fi

  # ---- Step 6: Update .gitignore ----
  log_header "6. Updating .gitignore"
  local gitignore="$project_path/.gitignore"
  local entries=(".pm/tasks.db" ".wm/" ".env.local" ".n2o-backup/")

  if [[ ! -f "$gitignore" ]]; then
    touch "$gitignore"
  fi

  for entry in "${entries[@]}"; do
    if ! grep -qxF "$entry" "$gitignore" 2>/dev/null; then
      echo "$entry" >> "$gitignore"
      log_success "Added '$entry' to .gitignore"
    fi
  done

  # ---- Step 7: Generate config helper script ----
  log_header "7. Generating config helper"
  cat > "$project_path/scripts/n2o-config.sh" <<'HELPER'
#!/bin/bash
# Auto-generated by n2o init — sources project config for use in skills/scripts.
# Usage: source scripts/n2o-config.sh

_N2O_CONFIG=".pm/config.json"

if [[ ! -f "$_N2O_CONFIG" ]]; then
  echo "Error: $_N2O_CONFIG not found. Are you in the project root?" >&2
  return 1 2>/dev/null || exit 1
fi

export N2O_VERSION=$(jq -r '.n2o_version' "$_N2O_CONFIG")
export N2O_PROJECT=$(jq -r '.project_name' "$_N2O_CONFIG")
export N2O_TEST_CMD=$(jq -r '.commands.test // ""' "$_N2O_CONFIG")
export N2O_TYPECHECK_CMD=$(jq -r '.commands.typecheck // ""' "$_N2O_CONFIG")
export N2O_LINT_CMD=$(jq -r '.commands.lint // ""' "$_N2O_CONFIG")
export N2O_BUILD_CMD=$(jq -r '.commands.build // ""' "$_N2O_CONFIG")
HELPER
  chmod +x "$project_path/scripts/n2o-config.sh"
  log_success "Created scripts/n2o-config.sh"

  # ---- Step 8: Register project ----
  if $do_register; then
    log_header "8. Registering project"
    register_project "$project_path"
  fi

  # ---- Done ----
  echo ""
  log_header "✅ N2O workflow initialized!"
  echo ""
  echo "  Project:  $project_path"
  echo "  Version:  $VERSION"
  echo "  Database: .pm/tasks.db"
  echo ""
  echo "  Next steps:"
  echo "    1. Review and fill in CLAUDE.md with project-specific context"
  echo "    2. Edit .pm/config.json if commands need adjustment"
  echo "    3. Start planning: invoke the /pm-agent skill"
  echo ""
}

# =============================================================================
# SYNC COMMAND
# =============================================================================

cmd_sync() {
  local project_path=""
  local dry_run=false
  local sync_all=false

  # Parse args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run) dry_run=true; shift ;;
      --all)     sync_all=true; shift ;;
      -*)        log_error "Unknown option: $1"; exit 1 ;;
      *)         project_path="$1"; shift ;;
    esac
  done

  if $sync_all; then
    if [[ ! -f "$PROJECTS_FILE" ]]; then
      log_error "No projects registered. Use 'n2o init <path> --register' first."
      exit 1
    fi

    local projects
    projects=$(jq -r '.projects[]' "$PROJECTS_FILE")
    local count
    count=$(echo "$projects" | wc -l)
    log_header "Syncing $count registered projects (v$VERSION)"

    while IFS= read -r p; do
      echo ""
      sync_project "$p" "$dry_run"
    done <<< "$projects"
    return
  fi

  if [[ -z "$project_path" ]]; then
    log_error "Usage: n2o sync <project-path> [--dry-run] or n2o sync --all [--dry-run]"
    exit 1
  fi

  project_path="$(cd "$project_path" && pwd)"
  sync_project "$project_path" "$dry_run"
}

sync_project() {
  local project_path="$1"
  local dry_run="$2"
  local changes=0
  local skipped=0

  if $dry_run; then
    log_header "DRY RUN — Sync: $project_path"
  else
    log_header "Syncing: $project_path"
  fi

  # Verify it's an n2o project
  if [[ ! -f "$project_path/.pm/config.json" ]]; then
    log_error "Not an N2O project (missing .pm/config.json). Run 'n2o init' first."
    return 1
  fi

  local project_version
  project_version=$(jq -r '.n2o_version // "unknown"' "$project_path/.pm/config.json")
  log_info "Current version: $project_version → $VERSION"

  local backup_dir="$project_path/.n2o-backup/$(date +%Y%m%d-%H%M%S)"
  local schema_changed=false

  # ---- Sync agents → .claude/skills/ ----
  log_header "Framework files"

  # Sync agents
  if [[ -d "$N2O_DIR/02-agents" ]]; then
    sync_directory "$N2O_DIR/02-agents" "$project_path/.claude/skills" "$backup_dir" "$dry_run" "agents"
  fi

  # Sync patterns
  if [[ -d "$N2O_DIR/03-patterns" ]]; then
    sync_directory "$N2O_DIR/03-patterns" "$project_path/.claude/skills" "$backup_dir" "$dry_run" "patterns"
  fi

  # Sync schema.sql
  if [[ -f "$N2O_DIR/.pm/schema.sql" ]]; then
    if ! diff -q "$N2O_DIR/.pm/schema.sql" "$project_path/.pm/schema.sql" &>/dev/null; then
      schema_changed=true
      if $dry_run; then
        log_warn "WOULD UPDATE: .pm/schema.sql"
        diff --color=auto "$project_path/.pm/schema.sql" "$N2O_DIR/.pm/schema.sql" 2>/dev/null || true
      else
        backup_file "$project_path/.pm/schema.sql" "$backup_dir"
        cp "$N2O_DIR/.pm/schema.sql" "$project_path/.pm/schema.sql"
        log_success "Updated .pm/schema.sql"
      fi
      ((changes++)) || true
    else
      log_info "Unchanged: .pm/schema.sql"
    fi
  fi

  # Sync scripts
  if [[ -d "$N2O_DIR/scripts" ]]; then
    sync_directory "$N2O_DIR/scripts" "$project_path/scripts" "$backup_dir" "$dry_run" "scripts"
  fi

  # ---- Skip project files ----
  log_header "Project files (never touched)"
  for pf in ".pm/config.json" ".pm/schema-extensions.sql" "CLAUDE.md" ".mcp.json"; do
    if [[ -f "$project_path/$pf" ]]; then
      log_info "Skipped: $pf"
      ((skipped++)) || true
    fi
  done

  # ---- Handle schema migration ----
  if $schema_changed && ! $dry_run; then
    echo ""
    log_warn "schema.sql has changed."
    read -rp "  Run schema migration on tasks.db? (y/N): " confirm
    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
      backup_file "$project_path/.pm/tasks.db" "$backup_dir"
      sqlite3 "$project_path/.pm/tasks.db" < "$project_path/.pm/schema.sql"
      log_success "Applied schema.sql to tasks.db"

      if [[ -f "$project_path/.pm/schema-extensions.sql" ]]; then
        if grep -qE '^\s*(CREATE|ALTER|INSERT|DROP)' "$project_path/.pm/schema-extensions.sql" 2>/dev/null; then
          sqlite3 "$project_path/.pm/tasks.db" < "$project_path/.pm/schema-extensions.sql"
          log_success "Applied schema-extensions.sql"
        fi
      fi
    fi
  fi

  # ---- Update version in config ----
  if ! $dry_run; then
    local tmp
    tmp=$(mktemp)
    jq --arg ver "$VERSION" '.n2o_version = $ver' "$project_path/.pm/config.json" > "$tmp"
    mv "$tmp" "$project_path/.pm/config.json"
  fi

  # ---- Summary ----
  echo ""
  if $dry_run; then
    log_info "Dry run complete. No files were modified."
  else
    log_success "Sync complete. Version: $VERSION"
    if [[ -d "$backup_dir" ]]; then
      log_info "Backups saved to: .n2o-backup/$(basename "$backup_dir")/"
    fi
  fi
}

# Sync a source directory into a destination, overwriting changed files
sync_directory() {
  local src="$1"
  local dest="$2"
  local backup_dir="$3"
  local dry_run="$4"
  local label="$5"

  mkdir -p "$dest"

  # Use rsync-like approach: find all files in source, compare with dest
  while IFS= read -r src_file; do
    local rel="${src_file#$src/}"
    local dest_file="$dest/$rel"

    if [[ -f "$dest_file" ]]; then
      if ! diff -q "$src_file" "$dest_file" &>/dev/null; then
        if $dry_run; then
          log_warn "WOULD UPDATE: $label/$rel"
        else
          backup_file "$dest_file" "$backup_dir"
          mkdir -p "$(dirname "$dest_file")"
          cp "$src_file" "$dest_file"
          log_success "Updated: $label/$rel"
        fi
      fi
    else
      if $dry_run; then
        log_warn "WOULD ADD: $label/$rel"
      else
        mkdir -p "$(dirname "$dest_file")"
        cp "$src_file" "$dest_file"
        log_success "Added: $label/$rel"
      fi
    fi
  done < <(find "$src" -type f -not -name '.DS_Store')
}

# Back up a file before overwriting
backup_file() {
  local file="$1"
  local backup_dir="$2"

  if [[ -f "$file" ]]; then
    local rel="${file#$project_path/}"
    local backup_path="$backup_dir/$rel"
    mkdir -p "$(dirname "$backup_path")"
    cp "$file" "$backup_path"
  fi
}

# =============================================================================
# MAIN
# =============================================================================

main() {
  check_deps

  local command="${1:-}"
  shift 2>/dev/null || true

  case "$command" in
    init)
      cmd_init "$@"
      ;;
    sync)
      cmd_sync "$@"
      ;;
    version|--version|-v)
      echo "n2o v$VERSION"
      ;;
    help|--help|-h|"")
      echo "n2o — N2O Workflow Framework CLI (v$VERSION)"
      echo ""
      echo "Usage:"
      echo "  n2o init <project-path> [--interactive] [--register]"
      echo "      Bootstrap a new project with N2O workflow files."
      echo ""
      echo "  n2o sync <project-path> [--dry-run]"
      echo "      Push framework updates to a project."
      echo ""
      echo "  n2o sync --all [--dry-run]"
      echo "      Push framework updates to all registered projects."
      echo ""
      echo "  n2o version"
      echo "      Print the current framework version."
      echo ""
      echo "  n2o help"
      echo "      Show this help message."
      ;;
    *)
      log_error "Unknown command: $command"
      echo "Run 'n2o help' for usage."
      exit 1
      ;;
  esac
}

main "$@"
